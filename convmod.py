#!/usr/bin/env python

import re
import os

dir = './co_async/'

GLOBAL_MODULE_FRAGMENT = re.compile(r'^\s*module;$')
IMPORT_STD = re.compile(r'^\s*import\s+std;$')
EXPORT_MODULE = re.compile(r'^\s*export\s+module\s+([a-zA-Z0-9_.]+)(:[a-zA-Z0-9_.]+)?;$')
IMPORT = re.compile(r'^\s*(export\s+)?import\s+(:)?([a-zA-Z0-9_.]+);$')
EXPORT = re.compile(r'^(\s*export\s+)')

# walk dir
for dirpath, dirnames, filenames in os.walk(dir):
    for filename in filenames:
        filepath = os.path.join(dirpath, filename)
        if filepath.endswith('.cppm') or filepath.endswith('.cpp'):
            res = ''
            with open(filepath, 'r') as f:
                current = None
                parent = None
                for line in f:
                    line = line.removesuffix('\n')
                    if 0: pass
                    elif m := re.match(GLOBAL_MODULE_FRAGMENT, line):
                        line = '/*{' + line + '}*/'
                    elif m := re.match(EXPORT_MODULE, line):
                        parent, partition = m.groups()
                        if partition:
                            current = parent + partition
                        else:
                            current = parent
                        line = '/*{' + line + '}*/'
                    elif m := re.match(IMPORT_STD, line):
                        line = '#include <bits/stdc++.h>/*{' + line + '}*/'
                    elif m := re.match(IMPORT, line):
                        export, colon, partition = m.groups()
                        if colon:
                            assert parent
                            dependency = parent + ':' + partition
                        else:
                            dependency = partition
                        line = '#include <' + dependency + '.hpp>/*{' + line + '}*/'
                    elif m := re.match(EXPORT, line):
                        export = m.group(0)
                        line = '/*[' + line + ']*/' + line[len(export):]
                    res += line + '\n'
            if 0:
                with open(filepath, 'w') as f:
                    f.write(res)
            else:
                print(res)


visited = set()
result = []

def dump(current):
    if current in visited:
        return
    visited.add(current)
    module = modules[current]
    for dependency in module['dependencies']:
        dump(dependency)
    result.append(module['source'])

for m in modules:
    dump(m)

source = '\n'.join(result)
source = '''#pragma once
/// Automatically Generated (DO NOT EDIT THIS FILE)
/// Source: https://github.com/archibate/co_async
{}
'''.format(source)
with open(out, 'w') as f:
    f.write(source)
