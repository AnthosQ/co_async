#pragma once
/// Automatically Generated (DO NOT EDIT THIS FILE)
/// Source: https://github.com/archibate/co_async

#include <cassert>
#include <cctype>
#include <cerrno>
#include <cfloat>
#include <ciso646>
#include <climits>
#include <clocale>
#include <cmath>
#include <csetjmp>
#include <csignal>
#include <cstdarg>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <cwchar>
#include <cwctype>

#if __cplusplus >= 201103L
#include <ccomplex>
#include <cfenv>
#include <cinttypes>
#if __has_include(<cstdalign>)
#include <cstdalign>
#endif
#include <cstdbool>
#include <cstdint>
#include <ctgmath>
#include <cuchar>
#endif

// C++
#include <algorithm>
#include <bitset>
#include <complex>
#include <deque>
#include <exception>
#include <fstream>
#include <functional>
#include <iomanip>
#include <ios>
#include <iosfwd>
#include <iostream>
#include <istream>
#include <iterator>
#include <limits>
#include <list>
#include <locale>
#include <map>
#include <memory>
#include <new>
#include <numeric>
#include <ostream>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <stdexcept>
#include <streambuf>
#include <string>
#include <typeinfo>
#include <utility>
#include <valarray>
#include <vector>

#if __cplusplus >= 201103L
#include <array>
#include <atomic>
#include <chrono>
#include <codecvt>
#include <condition_variable>
#include <forward_list>
#include <future>
#include <initializer_list>
#include <mutex>
#include <random>
#include <ratio>
#include <regex>
#include <scoped_allocator>
#include <system_error>
#include <thread>
#include <tuple>
#include <typeindex>
#include <type_traits>
#include <unordered_map>
#include <unordered_set>
#endif

#if __cplusplus >= 201402L
#include <shared_mutex>
#endif

#if __cplusplus >= 201703L
#include <any>
#include <charconv>
// #include <execution>
#include <filesystem>
#include <optional>
#include <memory_resource>
#include <string_view>
#include <variant>
#endif

#if __cplusplus >= 202002L
#include <barrier>
#include <bit>
#include <compare>
#include <concepts>
#if __cpp_impl_coroutine
# include <coroutine>
#endif
#include <latch>
#include <numbers>
#include <ranges>
#include <span>
#if __has_include(<stop_token>)
#include <stop_token>
#endif
#include <semaphore>
#include <source_location>
#if __has_include(<syncstream>)
#include <syncstream>
#endif
#include <version>
#endif

#if __cplusplus > 202002L
#if __has_include(<expected>)
#include <expected>
#endif
#if __has_include(<spanstream>)
#include <spanstream>
#endif
#if __has_include(<stacktrace>)
# include <stacktrace>
#endif
#if __has_include(<stdatomic.h>)
#include <stdatomic.h>
#endif
#endif

// #line 1 "./co_async/utils/non_void_helper.cpp"




namespace co_async {

       template <class T = void>
struct NonVoidHelper {
    using Type = T;
};

template <>
struct NonVoidHelper<void> {
    using Type = NonVoidHelper;

    explicit NonVoidHelper() = default;

    template <class T>
    constexpr friend T &&operator,(T &&t, NonVoidHelper) {
        return std::forward<T>(t);
    }

    char const *repr() const noexcept {
        return "NonVoidHelper";
    }
};

} // namespace co_async

// #line 1 "./co_async/utils/uninitialized.cpp"




namespace co_async {

template <class T>
struct Uninitialized {
    union {
        T mValue;
    };

    Uninitialized() noexcept {}

    Uninitialized(Uninitialized &&) = delete;

    ~Uninitialized() noexcept {}

    T moveValue() {
        T ret(std::move(mValue));
        mValue.~T();
        return ret;
    }

    template <class... Ts>
    void putValue(Ts &&...args) {
        new (std::addressof(mValue)) T(std::forward<Ts>(args)...);
    }
};

template <>
struct Uninitialized<void> {
    auto moveValue() {
        return NonVoidHelper<>{};
    }

    void putValue(NonVoidHelper<>) {}
};

template <class T>
struct Uninitialized<T const> : Uninitialized<T> {};

template <class T>
struct Uninitialized<T &> : Uninitialized<std::reference_wrapper<T>> {};

template <class T>
struct Uninitialized<T &&> : Uninitialized<T> {};

} // namespace co_async

// #line 1 "./co_async/awaiter/details/previous_awaiter.cpp"




namespace co_async {

struct PreviousAwaiter {
    std::coroutine_handle<> mPrevious;

    bool await_ready() const noexcept {
        return false;
    }

    std::coroutine_handle<>
    await_suspend(std::coroutine_handle<> coroutine) const noexcept {
        return mPrevious;
    }

    void await_resume() const noexcept {}
};

} // namespace co_async

// #line 1 "./co_async/awaiter/task.cpp"




namespace co_async {

template <class T>
struct Promise {
    auto initial_suspend() noexcept {
        return std::suspend_always();
    }

    auto final_suspend() noexcept {
        return PreviousAwaiter(mPrevious);
    }

    void unhandled_exception() noexcept {
        mException = std::current_exception();
    }

    void return_value(T &&ret) {
        mResult.putValue(std::move(ret));
    }

    void return_value(T const &ret) {
        mResult.putValue(ret);
    }

    T result() {
        if (mException) [[unlikely]] {
            std::rethrow_exception(mException);
        }
        return mResult.moveValue();
    }

    auto get_return_object() {
        return std::coroutine_handle<Promise>::from_promise(*this);
    }

    void setPrevious(std::coroutine_handle<> previous) noexcept {
        mPrevious = previous;
    }

    std::coroutine_handle<> mPrevious;
    std::exception_ptr mException{};
    Uninitialized<T> mResult; // destructed??

    Promise &operator=(Promise &&) = delete;
};

template <>
struct Promise<void> {
    auto initial_suspend() noexcept {
        return std::suspend_always();
    }

    auto final_suspend() noexcept {
        return PreviousAwaiter(mPrevious);
    }

    void unhandled_exception() noexcept {
        mException = std::current_exception();
    }

    void return_void() noexcept {}

    void result() {
        if (mException) [[unlikely]] {
            std::rethrow_exception(mException);
        }
    }

    auto get_return_object() {
        return std::coroutine_handle<Promise>::from_promise(*this);
    }

    void setPrevious(std::coroutine_handle<> previous) noexcept {
        mPrevious = previous;
    }

    std::coroutine_handle<> mPrevious;
    std::exception_ptr mException{};

    Promise &operator=(Promise &&) = delete;
};

       template <class T = void, class P = Promise<T>>
struct [[nodiscard]] Task {
    using promise_type = P;

    Task(std::coroutine_handle<promise_type> coroutine = nullptr) noexcept
        : mCoroutine(coroutine) {}

    Task(Task &&that) noexcept : mCoroutine(that.mCoroutine) {
        that.mCoroutine = nullptr;
    }

    Task &operator=(Task &&that) noexcept {
        std::swap(mCoroutine, that.mCoroutine);
    }

    ~Task() {
        if (mCoroutine)
            mCoroutine.destroy();
    }

    struct Awaiter {
        bool await_ready() const noexcept {
            return false;
        }

        std::coroutine_handle<promise_type>
        await_suspend(std::coroutine_handle<> coroutine) const noexcept {
            promise_type &promise = mCoroutine.promise();
            promise.setPrevious(coroutine);
            return mCoroutine;
        }

        T await_resume() const {
            return mCoroutine.promise().result();
        }

        std::coroutine_handle<promise_type> mCoroutine;
    };

    auto operator co_await() const noexcept {
        return Awaiter(mCoroutine);
    }

    operator std::coroutine_handle<promise_type>() const noexcept {
        return mCoroutine;
    }

    std::coroutine_handle<promise_type> release() noexcept {
        auto coroutine = mCoroutine;
        mCoroutine = nullptr;
        return coroutine;
    }

private:
    std::coroutine_handle<promise_type> mCoroutine;
};

       template <class Loop, class T, class P>
T run_task_on(Loop &loop, Task<T, P> const &t) {
    auto a = t.operator co_await();
    auto c = a.await_suspend(std::noop_coroutine());
    c.resume();
    while (!c.done()) {
        loop.run();
    }
    return a.await_resume();
};

} // namespace co_async

// #line 1 "./co_async/utils/simple_map.cpp"




namespace co_async {

       template <class K, class V>
struct SimpleMap {
    SimpleMap() = default;

    SimpleMap(std::initializer_list<std::pair<K, V>> init)
        : mData(init.begin(), init.end()) {}

    template <class Key>
        requires(requires(K k, Key key) {
            k < key;
            key < k;
        })
    V *at(Key &&key) noexcept {
        auto it = mData.find(std::forward<Key>(key));
        if (it == mData.end()) {
            return nullptr;
        }
        return std::addressof(it->second);
    }

    template <class Key>
        requires(requires(K k, Key key) {
            k < key;
            key < k;
        })
    V const *at(Key const &key) const noexcept {
        auto it = mData.find(key);
        if (it == mData.end()) {
            return nullptr;
        }
        return std::addressof(it->second);
    }

    template <class Key, std::invocable<V const &> F = std::identity>
        requires(requires(K k, Key key) {
            k < key;
            key < k;
        })
    decltype(std::optional(std::declval<std::invoke_result_t<F, V const &>>()))
    get(Key const &key, F &&func = {}) const noexcept {
        auto it = mData.find(key);
        if (it == mData.end()) {
            return std::nullopt;
        }
        return std::invoke(func, it->second);
    }

    V &insert_or_assign(K key, V value) {
        return mData.insert_or_assign(std::move(key), std::move(value))
            .first->second;
    }

    V &insert(K key, V value) {
        return mData.emplace(std::move(key), std::move(value)).first->second;
    }

    template <class Key>
        requires(requires(K k, Key key) {
            k < key;
            key < k;
        })
    bool contains(Key &&key) const noexcept {
        return mData.find(std::forward<Key>(key)) != mData.end();
    }

    template <class Key>
        requires(requires(K k, Key key) {
            k < key;
            key < k;
        })
    bool erase(Key &&key) {
        return mData.erase(std::forward<Key>(key)) != 0;
    }

    auto begin() const noexcept {
        return mData.begin();
    }

    auto end() const noexcept {
        return mData.end();
    }

    auto begin() noexcept {
        return mData.begin();
    }

    auto end() noexcept {
        return mData.end();
    }

private:
    std::map<K, V, std::less<>> mData;
};

} // namespace co_async

// #line 1 "./co_async/awaiter/concepts.cpp"




namespace co_async {

       template <class A>
concept Awaiter = requires(A a, std::coroutine_handle<> h) {
    { a.await_ready() };
    { a.await_suspend(h) };
    { a.await_resume() };
};

       template <class A>
concept Awaitable = Awaiter<A> || requires(A a) {
    { a.operator co_await() } -> Awaiter;
};

       template <class A>
struct AwaitableTraits {
    using Type = A;
};

template <Awaiter A>
struct AwaitableTraits<A> {
    using RetType = decltype(std::declval<A>().await_resume());
    using NonVoidRetType = NonVoidHelper<RetType>::Type;
    using Type = RetType;
    using AwaiterType = A;
};

template <class A>
    requires(!Awaiter<A> && Awaitable<A>)
struct AwaitableTraits<A>
    : AwaitableTraits<decltype(std::declval<A>().operator co_await())> {};

template <class... Ts>
struct TypeList {};

template <class Last>
struct TypeList<Last> {
    using FirstType = Last;
    using LastType = Last;
};

template <class First, class... Ts>
struct TypeList<First, Ts...> {
    using FirstType = First;
    using LastType = typename TypeList<Ts...>::LastType;
};

} // namespace co_async

// #line 1 "./co_async/awaiter/details/auto_destroy_promise.cpp"




namespace co_async {

struct AutoDestroyPromise {
    auto initial_suspend() noexcept {
        return std::suspend_always();
    }

    auto final_suspend() noexcept {
        std::coroutine_handle<AutoDestroyPromise>::from_promise(*this)
            .destroy();
        return std::suspend_always();
    }

    void unhandled_exception() noexcept {}

    void return_void() noexcept {}

    auto get_return_object() {
        return std::coroutine_handle<AutoDestroyPromise>::from_promise(*this);
    }

    void setPrevious(std::coroutine_handle<>) noexcept {}

    AutoDestroyPromise &operator=(AutoDestroyPromise &&) = delete;
};

} // namespace co_async

// #line 1 "./co_async/threading/basic_loop.cpp"




namespace co_async {

struct BasicLoop {
    void run() {
        while (!mQueue.empty()) {
            auto coroutine = mQueue.front();
            mQueue.pop_front();
            coroutine.resume();
        }
    }

    void push(std::coroutine_handle<> coroutine) {
        mQueue.push_back(coroutine);
    }

    BasicLoop() = default;
    BasicLoop(BasicLoop &&) = delete;

private:
    std::deque<std::coroutine_handle<>> mQueue;
};

template <Awaitable A>
inline Task<void, AutoDestroyPromise> taskEnqueueHelper(A a) {
    co_return co_await std::move(a);
}

template <class A>
    requires(!Awaitable<A> && std::invocable<A> &&
             Awaitable<std::invoke_result_t<A>>)
inline Task<void, AutoDestroyPromise> taskEnqueueHelper(A a) {
    return taskEnqueueHelper(std::invoke(std::move(a)));
}

inline void loop_enqueue(BasicLoop &loop, auto task) {
    auto t = taskEnqueueHelper(std::move(task));
    std::coroutine_handle<AutoDestroyPromise> coroutine = t;
    loop.push(coroutine);
    t.release();
}

} // namespace co_async

// #line 1 "./co_async/system/error_handling.cpp"


#ifdef __linux__
#include <linux/errno.h>
extern "C" [[gnu::const]] int *__errno_location(void) noexcept;
# define errno (*__errno_location())
#endif





namespace co_async {

#if CO_ASYNC_DEBUG
auto checkError(auto res, std::source_location const &loc =
                              std::source_location::current()) {
    if (res == -1) [[unlikely]] {
        throw std::system_error(errno, std::system_category(),
                                (std::string)loc.file_name() + ":" +
                                    std::to_string(loc.line()));
    }
    return res;
}

auto bypassSpecificError(auto res, int bypassval = -ETIME) {
    if (res == bypassval) {
        res = 0;
    }
    return res;
}

auto checkErrorReturn(auto res, std::source_location const &loc =
                                    std::source_location::current()) {
    if (res < 0) [[unlikely]] {
        throw std::system_error(-res, std::system_category(),
                                (std::string)loc.file_name() + ":" +
                                    std::to_string(loc.line()));
    }
    return res;
}

auto checkErrorNonBlock(
    auto res, int blockres = 0, int blockerr = EWOULDBLOCK,
    std::source_location const &loc = std::source_location::current()) {
    if (res == -1) {
        if (errno != blockerr) [[unlikely]] {
            throw std::system_error(errno, std::system_category(),
                                    (std::string)loc.file_name() + ":" +
                                        std::to_string(loc.line()));
        }
        res = blockres;
    }
    return res;
}
#else
auto checkError(auto res) {
    if (res == -1) [[unlikely]] {
        throw std::system_error(errno, std::system_category());
    }
    return res;
}

auto checkErrorReturn(auto res) {
    if (res < 0) [[unlikely]] {
        throw std::system_error(-res, std::system_category());
    }
    return res;
}

auto checkErrorNonBlock(auto res, int blockres = 0,
                        int blockerr = EWOULDBLOCK) {
    if (res == -1) {
        if (errno != blockerr) [[unlikely]] {
            throw std::system_error(errno, std::system_category());
        }
        res = blockres;
    }
    return res;
}
#endif

} // namespace co_async

// #line 1 "./co_async/system/uring_loop.cpp"


#ifdef __linux__
#include <liburing.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>
#endif





#ifdef __linux__

namespace co_async {

template <class Rep, class Period>
struct __kernel_timespec
durationToKernelTimespec(std::chrono::duration<Rep, Period> dur) {
    struct __kernel_timespec ts;
    auto secs = std::chrono::duration_cast<std::chrono::seconds>(dur);
    auto nsecs =
        std::chrono::duration_cast<std::chrono::nanoseconds>(dur - secs);
    ts.tv_sec = static_cast<std::uint64_t>(secs.count());
    ts.tv_nsec = static_cast<std::uint64_t>(nsecs.count());
    return ts;
}

template <class Clk, class Dur>
struct __kernel_timespec
timePointToKernelTimespec(std::chrono::time_point<Clk, Dur> tp) {
    return durationToKernelTimespec(tp.time_since_epoch());
}

struct UringLoop {
    inline void run();
    inline bool runBatched(
        std::size_t numBatch = 128,
        std::chrono::microseconds timeout = std::chrono::milliseconds(10));

    io_uring_sqe *getSqe() {
        io_uring_sqe *sqe = io_uring_get_sqe(&mRing);
        if (!sqe) [[unlikely]] {
            throw std::bad_alloc();
        }
        return sqe;
    }

    UringLoop &operator=(UringLoop &&) = delete;

    explicit UringLoop(std::size_t entries = 512) {
        checkErrorReturn(io_uring_queue_init(entries, &mRing, 0));
    }

    ~UringLoop() {
        io_uring_queue_exit(&mRing);
    }

    void doSubmit() {
        checkErrorReturn(io_uring_submit(&mRing));
    }

    operator BasicLoop &() {
        return mBasicLoop;
    }

private:
    io_uring mRing;
    BasicLoop mBasicLoop;
};

struct UringAwaiter {
    explicit UringAwaiter(UringLoop &loop, auto const &func) : mLoop(loop) {
        io_uring_sqe *sqe = mLoop.getSqe();
        func(sqe);
        io_uring_sqe_set_data(sqe, this);
        /* io_uring_sync_cancel_reg reg; */
        /* reg.flags; */
        /* io_uring_register_sync_cancel(&mLoop.mRing, &reg); */
    }

    void cancel() {
        io_uring_sqe *sqe = mLoop.getSqe();
        io_uring_prep_cancel(sqe, this, IORING_ASYNC_CANCEL_ALL);
        io_uring_sqe_set_data(sqe, nullptr);
    }

    UringAwaiter(UringAwaiter &&) = delete;

    bool await_ready() const noexcept {
        return false;
    }

    void await_suspend(std::coroutine_handle<> coroutine) {
        mPrevious = coroutine;
        mLoop.doSubmit();
    }

    int await_resume() const noexcept {
        return mRes;
    }

    UringLoop &mLoop;
    std::coroutine_handle<> mPrevious;
    int mRes = -ENOSYS;
};

void UringLoop::run() {
    mBasicLoop.run();
    io_uring_cqe *cqe;
    checkErrorReturn(io_uring_wait_cqe(&mRing, &cqe));
    auto *awaiter = reinterpret_cast<UringAwaiter *>(cqe->user_data);
    awaiter->mRes = cqe->res;
    io_uring_cqe_seen(&mRing, cqe);
    awaiter->mPrevious.resume();
}

bool UringLoop::runBatched(std::size_t numBatch,
                           std::chrono::microseconds timeout) {
    mBasicLoop.run();
    io_uring_cqe *cqe;
    auto ts = durationToKernelTimespec(timeout);
    int res = io_uring_wait_cqes(&mRing, &cqe, numBatch, &ts, nullptr);
    if (res == -ETIME) {
        return false;
    }
    checkErrorReturn(res);
    unsigned head, numGot = 0;
    io_uring_for_each_cqe(&mRing, head, cqe) {
        auto *awaiter = reinterpret_cast<UringAwaiter *>(cqe->user_data);
        awaiter->mRes = cqe->res;
        mBasicLoop.push(awaiter->mPrevious);
        ++numGot;
    }
    io_uring_cq_advance(&mRing, numGot);
    return true;
}

inline Task<int> uring_openat(UringLoop &loop, int dirfd, char const *path,
                              int flags, mode_t mode) {
    co_return checkErrorReturn(
        co_await UringAwaiter(loop, [&](io_uring_sqe *sqe) {
            io_uring_prep_openat(sqe, dirfd, path, flags, mode);
        }));
}

inline Task<int> uring_socket(UringLoop &loop, int domain, int type,
                              int protocol, unsigned int flags) {
    co_return checkErrorReturn(
        co_await UringAwaiter(loop, [&](io_uring_sqe *sqe) {
            io_uring_prep_socket(sqe, domain, type, protocol, flags);
        }));
}

inline Task<int> uring_accept(UringLoop &loop, int fd, struct sockaddr *addr,
                              socklen_t *addrlen, int flags) {
    co_return checkErrorReturn(
        co_await UringAwaiter(loop, [&](io_uring_sqe *sqe) {
            io_uring_prep_accept(sqe, fd, addr, addrlen, flags);
        }));
}

inline Task<int> uring_connect(UringLoop &loop, int fd,
                               const struct sockaddr *addr, socklen_t addrlen) {
    co_return checkErrorReturn(
        co_await UringAwaiter(loop, [&](io_uring_sqe *sqe) {
            io_uring_prep_connect(sqe, fd, addr, addrlen);
        }));
}

inline Task<int> uring_mkdirat(UringLoop &loop, int dirfd, char const *path,
                               mode_t mode) {
    co_return checkErrorReturn(
        co_await UringAwaiter(loop, [&](io_uring_sqe *sqe) {
            io_uring_prep_mkdirat(sqe, dirfd, path, mode);
        }));
}

inline Task<int> uring_linkat(UringLoop &loop, int olddirfd,
                              char const *oldpath, int newdirfd,
                              char const *newpath, int flags) {
    co_return checkErrorReturn(
        co_await UringAwaiter(loop, [&](io_uring_sqe *sqe) {
            io_uring_prep_linkat(sqe, olddirfd, oldpath, newdirfd, newpath,
                                 flags);
        }));
}

inline Task<int> uring_renameat(UringLoop &loop, int olddirfd,
                                char const *oldpath, int newdirfd,
                                char const *newpath, int flags) {
    co_return checkErrorReturn(
        co_await UringAwaiter(loop, [&](io_uring_sqe *sqe) {
            io_uring_prep_renameat(sqe, olddirfd, oldpath, newdirfd, newpath,
                                   flags);
        }));
}

inline Task<int> uring_unlinkat(UringLoop &loop, int dirfd, char const *path,
                                int flags = 0) {
    co_return checkErrorReturn(
        co_await UringAwaiter(loop, [&](io_uring_sqe *sqe) {
            io_uring_prep_unlinkat(sqe, dirfd, path, flags);
        }));
}

inline Task<int> uring_symlinkat(UringLoop &loop, char const *target,
                                 int newdirfd, char const *linkpath) {
    co_return checkErrorReturn(
        co_await UringAwaiter(loop, [&](io_uring_sqe *sqe) {
            io_uring_prep_symlinkat(sqe, target, newdirfd, linkpath);
        }));
}

inline Task<int> uring_statx(UringLoop &loop, int dirfd, char const *path,
                             int flags, unsigned int mask,
                             struct statx *statxbuf) {
    co_return co_await UringAwaiter(loop, [&](io_uring_sqe *sqe) {
        io_uring_prep_statx(sqe, dirfd, path, flags, mask, statxbuf);
    });
}

inline Task<std::size_t> uring_read(UringLoop &loop, int fd,
                                    std::span<char> buf, std::uint64_t offset) {
    co_return checkErrorReturn(
        co_await UringAwaiter(loop, [&](io_uring_sqe *sqe) {
            io_uring_prep_read(sqe, fd, buf.data(), buf.size(), offset);
        }));
}

inline Task<std::size_t> uring_write(UringLoop &loop, int fd,
                                     std::span<char const> buf,
                                     std::uint64_t offset) {
    co_return checkErrorReturn(
        co_await UringAwaiter(loop, [&](io_uring_sqe *sqe) {
            io_uring_prep_write(sqe, fd, buf.data(), buf.size(), offset);
        }));
}

inline Task<std::size_t> uring_readv(UringLoop &loop, int fd,
                                     std::span<iovec const> buf,
                                     std::uint64_t offset, int flags) {
    co_return checkErrorReturn(
        co_await UringAwaiter(loop, [&](io_uring_sqe *sqe) {
            io_uring_prep_readv2(sqe, fd, buf.data(), buf.size(), offset,
                                 flags);
        }));
}

inline Task<std::size_t> uring_writev(UringLoop &loop, int fd,
                                      std::span<iovec const> buf,
                                      std::uint64_t offset, int flags) {
    co_return checkErrorReturn(
        co_await UringAwaiter(loop, [&](io_uring_sqe *sqe) {
            io_uring_prep_writev2(sqe, fd, buf.data(), buf.size(), offset,
                                  flags);
        }));
}

inline Task<std::size_t> uring_recv(UringLoop &loop, int fd,
                                    std::span<char> buf, int flags) {
    co_return checkErrorReturn(
        co_await UringAwaiter(loop, [&](io_uring_sqe *sqe) {
            io_uring_prep_recv(sqe, fd, buf.data(), buf.size(), flags);
        }));
}

inline Task<std::size_t> uring_send(UringLoop &loop, int fd,
                                    std::span<char const> buf, int flags,
                                    int zc_flags) {
    co_return checkErrorReturn(
        co_await UringAwaiter(loop, [&](io_uring_sqe *sqe) {
            io_uring_prep_send_zc(sqe, fd, buf.data(), buf.size(), flags,
                                  zc_flags);
        }));
}

inline Task<std::size_t> uring_recvmsg(UringLoop &loop, int fd,
                                       struct msghdr *msg, unsigned int flags) {
    co_return checkErrorReturn(
        co_await UringAwaiter(loop, [&](io_uring_sqe *sqe) {
            io_uring_prep_recvmsg(sqe, fd, msg, flags);
        }));
}

inline Task<std::size_t> uring_sendmsg(UringLoop &loop, int fd,
                                       struct msghdr *msg, unsigned int flags) {
    co_return checkErrorReturn(
        co_await UringAwaiter(loop, [&](io_uring_sqe *sqe) {
            io_uring_prep_sendmsg_zc(sqe, fd, msg, flags);
        }));
}

inline Task<int> uring_close(UringLoop &loop, int fd) {
    co_return checkErrorReturn(co_await UringAwaiter(
        loop, [&](io_uring_sqe *sqe) { io_uring_prep_close(sqe, fd); }));
}

inline Task<int> uring_shutdown(UringLoop &loop, int fd, int how) {
    co_return checkErrorReturn(
        co_await UringAwaiter(loop, [&](io_uring_sqe *sqe) {
            io_uring_prep_shutdown(sqe, fd, how);
        }));
}

inline Task<int> uring_fsync(UringLoop &loop, int fd, unsigned int flags) {
    co_return checkErrorReturn(co_await UringAwaiter(
        loop, [&](io_uring_sqe *sqe) { io_uring_prep_fsync(sqe, fd, flags); }));
}

inline Task<int> uring_cancel_fd(UringLoop &loop, int fd, unsigned int flags) {
    co_return co_await UringAwaiter(loop, [&](io_uring_sqe *sqe) {
        io_uring_prep_cancel_fd(sqe, fd, flags);
    });
}

inline Task<int> uring_timeout(UringLoop &loop, struct __kernel_timespec ts,
                               unsigned int count, unsigned int flags) {
    int res = co_await UringAwaiter(loop, [&](io_uring_sqe *sqe) {
        io_uring_prep_timeout(sqe, &ts, count, flags);
    });
    if (res == -ETIME) [[likely]]
        res = 0;
    co_return checkErrorReturn(res);
}

template <class Rep, class Period>
inline Task<int> uring_timeout(UringLoop &loop,
                               std::chrono::duration<Rep, Period> dur,
                               std::size_t count) {
    return uring_timeout(loop, durationToKernelTimespec(dur), count,
                         IORING_TIMEOUT_ETIME_SUCCESS |
                             IORING_TIMEOUT_REALTIME);
}

template <class Clk, class Dur>
inline Task<int> uring_timeout(UringLoop &loop,
                               std::chrono::time_point<Clk, Dur> tp,
                               std::size_t count) {
    return uring_timeout(loop, timePointToKernelTimespec(tp), count,
                         IORING_TIMEOUT_ETIME_SUCCESS | IORING_TIMEOUT_ABS |
                             IORING_TIMEOUT_REALTIME);
}

} // namespace co_async
#endif

// #line 1 "./co_async/system/system_loop.cpp"




namespace co_async {

       inline UringLoop loop;

       inline void enqueue(auto task) {
    loop_enqueue(loop, std::move(task));
}

} // namespace co_async

// #line 1 "./co_async/system/fs.cpp"


#ifdef __linux__
#include <linux/errno.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#endif





#ifdef __linux__


namespace co_async {

       struct [[nodiscard]] FileHandle {
    FileHandle() : mFileNo(-1) {}

    explicit FileHandle(int fileNo) noexcept : mFileNo(fileNo) {}

    FileHandle(FileHandle &&that) noexcept : mFileNo(that.mFileNo) {
        that.mFileNo = -1;
    }

    FileHandle &operator=(FileHandle &&that) noexcept {
        std::swap(mFileNo, that.mFileNo);
        return *this;
    }

    ~FileHandle() {
        if (mFileNo != -1)
            close(mFileNo);
    }

    int fileNo() const noexcept {
        return mFileNo;
    }

    int releaseFile() noexcept {
        int ret = mFileNo;
        mFileNo = -1;
        return ret;
    }

private:
    int mFileNo;
};

       struct [[nodiscard]] FilePath {
    explicit FilePath(std::filesystem::path path, int dirfd = AT_FDCWD)
        : mPath(path),
          mDirFd(dirfd) {}

    char const *c_str() const noexcept {
        return mPath.c_str();
    }

    std::filesystem::path path() const {
        return mPath;
    }

    int dir_file() const noexcept {
        return mDirFd;
    }

private:
    std::filesystem::path mPath;
    int mDirFd;
};

       struct FileStat {
    struct statx *getNativeStatx() {
        return &mStatx;
    }

private:
    struct statx mStatx;
};

       enum class OpenMode : int {
    Read = O_RDONLY,
    Write = O_WRONLY | O_TRUNC | O_CREAT,
    ReadWrite = O_RDWR | O_CREAT,
    Append = O_WRONLY | O_APPEND | O_CREAT,
};

       inline Task<FileHandle> fs_open(FileHandle const &dir, FilePath path,
                                       OpenMode mode, mode_t access = 0644) {
    int oflags = (int)mode;
    int fd = co_await uring_openat(loop, path.dir_file(), path.c_str(), oflags,
                                   access);
    FileHandle file(fd);
    co_return file;
}

       inline Task<> fs_close(FileHandle &&file) {
    co_await uring_close(loop, file.fileNo());
    file.releaseFile();
}

       inline Task<> fs_mkdir(FilePath path, mode_t access = 0755) {
    co_await uring_mkdirat(loop, path.dir_file(), path.c_str(), access);
}

       inline Task<> fs_link(FilePath oldpath, FilePath newpath) {
    co_await uring_linkat(loop, oldpath.dir_file(), oldpath.c_str(),
                          newpath.dir_file(), newpath.c_str(), 0);
}

       inline Task<> fs_symlink(FilePath target, FilePath linkpath) {
    co_await uring_symlinkat(loop, target.c_str(), linkpath.dir_file(),
                             linkpath.c_str());
}

       inline Task<> fs_unlink(FilePath path) {
    co_await uring_unlinkat(loop, path.dir_file(), path.c_str(), 0);
}

       inline Task<> fs_rmdir(FilePath path) {
    co_await uring_unlinkat(loop, path.dir_file(), path.c_str(), AT_REMOVEDIR);
}

       inline Task<std::optional<FileStat>> fs_stat(FilePath path) {
    FileStat ret;
    int res = co_await uring_statx(loop, path.dir_file(), path.c_str(), 0,
                                   STATX_ALL, ret.getNativeStatx());
    int const allowed[] = {ENOENT, ENOTDIR, ENAMETOOLONG, ELOOP, EACCES};
    if (res < 0) {
        res = -res;
        for (auto e: allowed) {
            if (res == e) {
                co_return std::nullopt;
            }
        }
    }
    co_return ret;
}

       inline Task<std::size_t>
fs_read(FileHandle &file, std::span<char> buffer, std::uint64_t offset = -1) {
    return uring_read(loop, file.fileNo(), buffer, offset);
}

       inline Task<std::size_t> fs_write(FileHandle &file,
                                         std::span<char const> buffer,
                                         std::uint64_t offset = -1) {
    return uring_write(loop, file.fileNo(), buffer, offset);
}

} // namespace co_async
#endif

// #line 1 "./co_async/iostream/stream_base.cpp"




namespace co_async {

template <class Reader>
struct IStreamBase {
    explicit IStreamBase(std::size_t bufferSize = 8192)
        : mBuffer(std::make_unique<char[]>(bufferSize)),
          mBufSize(bufferSize) {}

    IStreamBase(IStreamBase &&) = default;
    IStreamBase &operator=(IStreamBase &&) = default;

    Task<std::optional<char>> getchar() {
        if (bufferEmpty()) {
            if (!co_await fillBuffer()) [[unlikely]] {
                co_return std::nullopt;
            }
        }
        char c = mBuffer[mIndex];
        ++mIndex;
        co_return c;
    }

    Task<> getline(std::string &s, char eol) {
        std::size_t start = mIndex;
        while (true) {
            for (std::size_t i = start; i < mEnd; ++i) {
                if (mBuffer[i] == eol) {
                    s.append(mBuffer.get() + start, i - start);
                    mIndex = i + 1;
                    co_return;
                }
            }
            start = 0;
            if (!co_await fillBuffer()) [[unlikely]] {
                co_return;
            }
        }
    }

    Task<> getline(std::string &s, std::string_view eol) {
        while (true) {
        again:
            co_await getline(s, eol.front());
            for (std::size_t i = 1; i < eol.size(); ++i) {
                if (bufferEmpty()) {
                    if (!co_await fillBuffer()) [[unlikely]] {
                        co_return;
                    }
                }
                char c = mBuffer[mIndex];
                if (eol[i] == c) [[likely]] {
                    ++mIndex;
                } else {
                    s.append(eol.data(), i);
                    goto again;
                }
            }
            co_return;
        }
    }

    Task<std::string> getline(char eol) {
        std::string s;
        co_await getline(s, eol);
        co_return s;
    }

    Task<std::string> getline(std::string_view eol) {
        std::string s;
        co_await getline(s, eol);
        co_return s;
    }

    Task<> getn(std::string &s, std::size_t n) {
        std::size_t start = mIndex;
        while (true) {
            auto end = start + n;
            if (end <= mEnd) {
                s.append(mBuffer.get() + start, end - start);
                mIndex = end;
                co_return;
            }
            s.append(mBuffer.get() + start, mEnd - start);
            start = 0;
            if (!co_await fillBuffer()) [[unlikely]] {
                co_return;
            }
        }
    }

    Task<std::string> getn(std::size_t n) {
        std::string s;
        co_await getn(s, n);
        co_return s;
    }

    Task<> getall(std::string &s) {
        std::size_t start = mIndex;
        do {
            s.append(mBuffer.get() + start, mEnd - start);
            start = 0;
        } while (co_await fillBuffer());
    }

private:
    bool bufferEmpty() const noexcept {
        return mIndex == mEnd;
    }

    Task<bool> fillBuffer() {
        auto *that = static_cast<Reader *>(this);
        mEnd = co_await that->read(std::span(mBuffer.get(), mBufSize));
        mIndex = 0;
        co_return mEnd != 0;
    }

    std::unique_ptr<char[]> mBuffer;
    std::size_t mIndex = 0;
    std::size_t mEnd = 0;
    std::size_t mBufSize = 0;
};

       struct StreamShutdownException {};

template <class Writer>
struct OStreamBase {
    explicit OStreamBase(std::size_t bufferSize = 8192)
        : mBuffer(std::make_unique<char[]>(bufferSize)),
          mBufSize(bufferSize) {}

    OStreamBase(OStreamBase &&) = default;
    OStreamBase &operator=(OStreamBase &&) = default;

    Task<> putchar(char c) {
        if (bufferFull()) {
            co_await flush();
        }
        mBuffer[mIndex] = c;
        ++mIndex;
    }

    Task<> puts(std::string_view s) {
        auto p = s.data();
        auto const pe = s.data() + s.size();
    again:
        if (pe - p <= mBufSize - mIndex) {
            auto b = mBuffer.get() + mIndex;
            mIndex += pe - p;
            while (p < pe) {
                *b++ = *p++;
            }
        } else {
            auto b = mBuffer.get() + mIndex;
            auto const be = mBuffer.get() + mBufSize;
            mIndex = mBufSize;
            while (b < be) {
                *b++ = *p++;
            }
            co_await flush();
            mIndex = 0;
            goto again;
        }
    }

    Task<> putline(std::string_view s) {
        co_await puts(s);
        co_await putchar('\n');
        co_await flush();
    }

    Task<> flush() {
        if (mIndex) [[likely]] {
            auto *that = static_cast<Writer *>(this);
            auto buf = std::span(mBuffer.get(), mIndex);
            auto len = co_await that->write(buf);
            while (len != buf.size()) [[unlikely]] {
                buf = buf.subspan(len);
                len = co_await that->write(buf);
            }
            if (len == 0) [[unlikely]] {
                throw StreamShutdownException();
            }
            mIndex = 0;
        }
    }

private:
    bool bufferFull() const noexcept {
        return mIndex == mBufSize;
    }

    std::unique_ptr<char[]> mBuffer;
    std::size_t mIndex = 0;
    std::size_t mBufSize = 0;
};

template <class StreamBuf>
struct IOStreamBase : IStreamBase<StreamBuf>, OStreamBase<StreamBuf> {
    explicit IOStreamBase(std::size_t bufferSize = 8192)
        : IStreamBase<StreamBuf>(bufferSize),
          OStreamBase<StreamBuf>(bufferSize) {}
};

       template <class StreamBuf>
struct [[nodiscard]] IOStream : IOStreamBase<IOStream<StreamBuf>>, StreamBuf {
    template <class... Args>
        requires std::constructible_from<StreamBuf, Args...>
    explicit IOStream(Args &&...args)
        : IOStreamBase<IOStream<StreamBuf>>(),
          StreamBuf(std::forward<Args>(args)...) {}

    IOStream() = default;
};

       template <class StreamBuf>
struct [[nodiscard]] OStream : OStreamBase<OStream<StreamBuf>>, StreamBuf {
    template <class... Args>
        requires std::constructible_from<StreamBuf, Args...>
    explicit OStream(Args &&...args)
        : OStreamBase<OStream<StreamBuf>>(),
          StreamBuf(std::forward<Args>(args)...) {}

    OStream() = default;
};

       template <class StreamBuf>
struct [[nodiscard]] IStream : IStreamBase<OStream<StreamBuf>>, StreamBuf {
    template <class... Args>
        requires std::constructible_from<StreamBuf, Args...>
    explicit IStream(Args &&...args)
        : IStreamBase<IStream<StreamBuf>>(),
          StreamBuf(std::forward<Args>(args)...) {}

    IStream() = default;
};

} // namespace co_async

// #line 1 "./co_async/iostream/file_stream.cpp"




namespace co_async {

       struct FileBuf {
    Task<std::size_t> read(std::span<char> buffer) {
        return fs_read(mFile, buffer);
    }

    Task<std::size_t> write(std::span<char const> buffer) {
        return fs_write(mFile, buffer);
    }

    FileHandle release() noexcept {
        return std::move(mFile);
    }

    explicit FileBuf(FileHandle file) : mFile(std::move(file)) {}

private:
    FileHandle mFile;
};

       using FileIStream = IStream<FileBuf>;
       using FileOStream = OStream<FileBuf>;
       using FileStream = IOStream<FileBuf>;

} // namespace co_async

// #line 1 "./co_async/http/http_status_code.cpp"




namespace co_async {

inline std::string_view getHTTPStatusName(int status) {
    using namespace std::string_view_literals;
    static constexpr std::pair<int, std::string_view> lut[] = {
        {100, "Continue"sv},
        {101, "Switching Protocols"sv},
        {102, "Processing"sv},

        {200, "OK"sv},
        {201, "Created"sv},
        {202, "Accepted"sv},
        {203, "Non-Authoritative Information"sv},
        {204, "No Content"sv},
        {205, "Reset Content"sv},
        {206, "Partial Content"sv},
        {207, "Multi-Status"sv},
        {208, "Already Reported"sv},
        {226, "IM Used"sv},

        {300, "Multiple Choices"sv},
        {301, "Moved Permanently"sv},
        {302, "Found"sv},
        {303, "See Other"sv},
        {304, "Not Modified"sv},
        {305, "Use Proxy"sv},
        {306, "Switch Proxy"sv},
        {307, "Temporary Redirect"sv},
        {308, "Permanent Redirect"sv},

        {400, "Bad Request"sv},
        {401, "Unauthorized"sv},
        {402, "Payment Required"sv},
        {403, "Forbidden"sv},
        {404, "Not Found"sv},
        {405, "Method Not Allowed"sv},
        {406, "Not Acceptable"sv},
        {407, "Proxy Authentication Required"sv},
        {408, "Request Timeout"sv},
        {409, "Conflict"sv},
        {410, "Gone"sv},
        {411, "Length Required"sv},
        {412, "Precondition Failed"sv},
        {413, "Payload Too Large"sv},
        {414, "URI Too Long"sv},
        {415, "Unsupported Media Type"sv},
        {416, "Range Not Satisfiable"sv},
        {417, "Expectation Failed"sv},
        {418, "I'm a teapot"sv},
        {421, "Misdirected Request"sv},
        {422, "Unprocessable Entity"sv},
        {423, "Locked"sv},
        {424, "Failed Dependency"sv},
        {426, "Upgrade Required"sv},
        {428, "Precondition Required"sv},
        {429, "Too Many Requests"sv},
        {431, "Request Header Fields Too Large"sv},
        {451, "Unavailable For Legal Reasons"sv},

        {500, "Internal Server Error"sv},
        {501, "Not Implemented"sv},
        {502, "Bad Gateway"sv},
        {503, "Service Unavailable"sv},
        {504, "Gateway Timeout"sv},
        {505, "HTTP Version Not Supported"sv},
        {506, "Variant Also Negotiates"sv},
        {507, "Insufficient Storage"sv},
        {508, "Loop Detected"sv},
        {510, "Not Extended"sv},
        {511, "Network Authentication Required"sv},
    };
    if (status == 200) {
        return "OK"sv;
    }
    auto it = std::lower_bound(
        std::begin(lut), std::end(lut), status,
        [](auto const &p, auto status) { return p.first < status; });
    if (it == std::end(lut) || it->first != status) [[unlikely]] {
        return "Unknown"sv;
    } else {
        return it->second;
    }
}

} // namespace co_async

// #line 1 "./co_async/utils/string_utils.cpp"




namespace co_async {

template <class T>
struct from_string_t;

template <>
struct from_string_t<std::string> {
    std::string operator()(std::string_view s) const {
        return std::string(s);
    }
};

template <>
struct from_string_t<std::string_view> {
    std::string_view operator()(std::string_view s) const {
        return s;
    }
};

template <std::integral T>
struct from_string_t<T> {
    std::optional<T> operator()(std::string_view s, int base = 10) const {
        T result;
        auto [p, ec] =
            std::from_chars(s.data(), s.data() + s.size(), result, base);
        if (ec != std::errc()) [[unlikely]] {
            return std::nullopt;
        }
        if (p != s.data() + s.size()) [[unlikely]] {
            return std::nullopt;
        }
        return result;
    }
};

template <std::floating_point T>
struct from_string_t<T> {
    std::optional<T>
    operator()(std::string_view s,
               std::chars_format fmt = std::chars_format::general) const {
        T result;
        auto [p, ec] =
            std::from_chars(s.data(), s.data() + s.size(), result, fmt);
        if (ec != std::errc()) [[unlikely]] {
            return std::nullopt;
        }
        if (p != s.data() + s.size()) [[unlikely]] {
            return std::nullopt;
        }
        return result;
    }
};

       template <class T>
inline constexpr from_string_t<T> from_string;

template <class T = void>
struct to_string_t;

template <>
struct to_string_t<void> {
    template <class U>
    void operator()(std::string &result, U &&value) const {
        to_string_t<std::decay_t<U>>()(result, std::forward<U>(value));
    }

    template <class U>
    std::string operator()(U &&value) const {
        std::string result;
        operator()(result, std::forward<U>(value));
        return result;
    }
};

template <>
struct to_string_t<std::string> {
    void operator()(std::string &result, std::string const &value) const {
        result.assign(value);
    }
};

template <>
struct to_string_t<std::string_view> {
    void operator()(std::string &result, std::string_view value) const {
        result.assign(value);
    }
};

template <std::integral T>
struct to_string_t<T> {
    void operator()(std::string &result, T value) const {
        result.resize(std::numeric_limits<T>::digits10 + 1, '\0');
        auto [p, ec] =
            std::to_chars(result.data(), result.data() + result.size(), value);
        if (ec != std::errc()) [[unlikely]] {
            throw std::system_error(std::make_error_code(ec), "to_chars");
        }
        result.resize(p - result.data());
    }
};

template <std::floating_point T>
struct to_string_t<T> {
    void operator()(std::string &result, T value) const {
        result.resize(std::numeric_limits<T>::max_digits10 + 1, '\0');
        auto [p, ec] =
            std::to_chars(result.data(), result.data() + result.size(), value);
        if (ec != std::errc()) [[unlikely]] {
            throw std::system_error(std::make_error_code(ec), "to_chars");
        }
        result.resize(p - result.data());
    }
};

       inline constexpr to_string_t<> to_string;

} // namespace co_async

// #line 1 "./co_async/http/uri.cpp"




namespace co_async {

struct URIParams : SimpleMap<std::string, std::string> {
    using SimpleMap<std::string, std::string>::SimpleMap;
};

struct URI {
    std::string path;
    URIParams params;

private:
    static std::uint8_t fromHex(char c) {
        if ('0' <= c && c <= '9')
            return c - '0';
        else if ('A' <= c && c <= 'F')
            return c - 'A' + 10;
        else [[unlikely]]
            return 0;
    }

    static bool isCharUrlSafe(char c) {
        if ('0' <= c && c <= '9') {
            return true;
        }
        if ('a' <= c && c <= 'z') {
            return true;
        }
        if ('A' <= c && c <= 'Z') {
            return true;
        }
        if (c == '-' || c == '_' || c == '.') {
            return true;
        }
        return false;
    }

public:
    static void urlDecode(std::string &r, std::string_view s) {
        std::size_t b = 0;
        while (true) {
            auto i = s.find('%', b);
            if (i == std::string_view::npos || i + 3 > s.size()) {
                r.append(s.data() + b, s.data() + s.size());
                break;
            }
            r.append(s.data() + b, s.data() + i);
            char c1 = s[i + 1];
            char c2 = s[i + 2];
            r.push_back((fromHex(c1) << 4) | fromHex(c2));
            b = i + 3;
        }
    }

    static std::string urlDecode(std::string_view s) {
        std::string r;
        urlDecode(r, s);
        return r;
    }

    static void urlEncode(std::string &r, std::string_view s) {
        static constexpr char lut[] = "0123456789ABCDEF";
        for (char c: s) {
            if (isCharUrlSafe(c)) {
                r.push_back(c);
            } else {
                r.push_back('%');
                r.push_back(lut[static_cast<std::uint8_t>(c) >> 4]);
                r.push_back(lut[static_cast<std::uint8_t>(c) & 0xF]);
            }
        }
    }

    static std::string urlEncode(std::string_view s) {
        std::string r;
        urlEncode(r, s);
        return r;
    }

    static URI parse(std::string_view uri) {
        auto path = uri;
        URIParams params;

        auto i = uri.find('?');
        if (i != std::string_view::npos) {
            path = uri.substr(0, i);

            auto pairs = uri.substr(i + 1);
            for (auto pa: pairs | std::views::split('&')) {
                std::string_view pair(pa.data(), pa.data() + pa.size());
                auto j = pair.find('=');
                if (j != std::string_view::npos) {
                    auto k = pair.substr(0, j);
                    auto v = pair.substr(j + 1);
                    params.insert_or_assign(std::string(k), urlDecode(v));
                }
            }
        }

        return {std::string(path), std::move(params)};
    }

    void dump(std::string &r) const {
        r.append(path);
        char queryChar = '?';
        for (auto &[k, v]: params) {
            r.push_back(queryChar);
            urlEncode(r, k);
            r.push_back('=');
            urlEncode(r, v);
            queryChar = '&';
        }
    }

    std::string dump() const {
        std::string r;
        dump(r);
        return r;
    }
};

} // namespace co_async

// #line 1 "./co_async/http/http11.cpp"




namespace co_async {

struct HTTPHeaders : SimpleMap<std::string, std::string> {
    using SimpleMap<std::string, std::string>::SimpleMap;
};

struct HTTPRequest {
    std::string method;
    URI uri;
    HTTPHeaders headers;
    std::string body;

    Task<> write_into(auto &sock) const {
        using namespace std::string_view_literals;
        co_await sock.puts(method);
        co_await sock.putchar(' ');
        co_await sock.puts(uri.dump());
        co_await sock.puts(" HTTP/1.1\r\n"sv);
        for (auto const &[k, v]: headers) {
            co_await sock.puts(k);
            co_await sock.puts(": "sv);
            co_await sock.puts(v);
            co_await sock.puts("\r\n"sv);
        }
        if (body.empty()) {
            co_await sock.puts("\r\n"sv);
        } else {
            co_await sock.puts("content-length: "sv);
            co_await sock.puts(to_string(body.size()));
            co_await sock.puts("\r\n\r\n"sv);
            co_await sock.puts(body);
        }
        co_await sock.flush();
    }

    Task<> read_from(auto &sock) {
        using namespace std::string_view_literals;
        auto line = co_await sock.getline("\r\n"sv);
        auto pos = line.find(' ');
        if (pos == line.npos || pos == line.size() - 1) [[unlikely]] {
            throw std::invalid_argument("invalid http request");
        }
        method = line.substr(0, pos);
        auto pos2 = line.find(' ', pos + 1);
        if (pos2 == line.npos || pos2 == line.size() - 1) [[unlikely]] {
            throw std::invalid_argument("invalid http request");
        }
        uri = URI::parse(line.substr(pos + 1, pos2 - pos - 1));
        while (true) {
            auto line = co_await sock.getline("\r\n"sv);
            if (line.empty()) {
                break;
            }
            auto pos = line.find(':');
            if (pos == line.npos || pos == line.size() - 1 ||
                line[pos + 1] != ' ') [[unlikely]] {
                throw std::invalid_argument("invalid http request");
            }
            auto key = line.substr(0, pos);
            for (auto &c: key) {
                if (c >= 'A' && c <= 'Z') {
                    c += 'a' - 'A';
                }
            }
            headers.insert_or_assign(std::move(key), line.substr(pos + 2));
        }
        if (auto p =
                headers.get("content-length"sv, from_string<std::size_t>)) {
            body = co_await sock.getn(*p);
        }
    }

    auto repr() const {
        return std::make_tuple(method, uri, headers, body);
    }
};

struct HTTPResponse {
    int status;
    HTTPHeaders headers;
    std::string body;

    Task<> write_into(auto &sock) const {
        using namespace std::string_view_literals;
        co_await sock.puts("HTTP/1.1 "sv);
        co_await sock.puts(to_string(status));
        co_await sock.putchar(' ');
        co_await sock.puts(getHTTPStatusName(status));
        co_await sock.puts("\r\n"sv);
        for (auto const &[k, v]: headers) {
            co_await sock.puts(k);
            co_await sock.puts(": "sv);
            co_await sock.puts(v);
            co_await sock.puts("\r\n"sv);
        }
        if (body.empty()) {
            co_await sock.puts("\r\n"sv);
        } else {
            co_await sock.puts("content-length: "sv);
            co_await sock.puts(to_string(body.size()));
            co_await sock.puts("\r\n\r\n"sv);
            co_await sock.puts(body);
        }
        co_await sock.flush();
    }

    Task<> read_from(auto &sock) {
        using namespace std::string_view_literals;
        auto line = co_await sock.getline("\r\n"sv);
        if (line.size() <= 9 || line.substr(0, 9) != "HTTP/1.1 "sv)
            [[unlikely]] {
            throw std::invalid_argument("invalid http response");
        }
        status = from_string<int>(line.substr(9));
        while (true) {
            auto line = co_await sock.getline("\r\n"sv);
            if (line.empty()) {
                break;
            }
            auto pos = line.find(':');
            if (pos == line.npos || pos == line.size() - 1 ||
                line[pos + 1] != ' ') [[unlikely]] {
                throw std::invalid_argument("invalid http response");
            }
            auto key = line.substr(0, pos);
            for (auto &c: key) {
                if (c >= 'A' && c <= 'Z') {
                    c += 'a' - 'A';
                }
            }
            headers.insert_or_assign(std::move(key), line.substr(pos + 2));
        }
        if (auto p =
                headers.get("content-length"sv, from_string<std::size_t>)) {
            body = co_await sock.getn(*p);
        }
    }

    auto repr() const {
        return std::make_tuple(status, headers, body);
    }
};

} // namespace co_async

// #line 1 "./co_async/system/socket.cpp"


#ifdef __linux__
#include <sys/types.h>
#include <sys/socket.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <sys/un.h>
#endif





#ifdef __linux__

namespace co_async {

       struct IpAddress {
    explicit IpAddress(struct in_addr const &addr) noexcept : mAddr(addr) {}

    explicit IpAddress(struct in6_addr const &addr6) noexcept : mAddr(addr6) {}

    IpAddress(char const *ip) {
        in_addr addr = {};
        in6_addr addr6 = {};
        if (checkError(inet_pton(AF_INET, ip, &addr))) {
            mAddr = addr;
            return;
        }
        if (checkError(inet_pton(AF_INET6, ip, &addr6))) {
            mAddr = addr6;
            return;
        }
        hostent *hent = gethostbyname(ip);
        for (int i = 0; hent->h_addr_list[i]; i++) {
            if (hent->h_addrtype == AF_INET) {
                std::memcpy(&addr, hent->h_addr_list[i], sizeof(in_addr));
                mAddr = addr;
                return;
            } else if (hent->h_addrtype == AF_INET6) {
                std::memcpy(&addr6, hent->h_addr_list[i], sizeof(in6_addr));
                mAddr = addr6;
                return;
            }
        }
        throw std::invalid_argument("invalid domain name or ip address");
    }

    std::string toString() const {
        if (mAddr.index() == 1) {
            char buf[INET6_ADDRSTRLEN + 1] = {};
            inet_ntop(AF_INET6, &std::get<1>(mAddr), buf, sizeof(buf));
            return buf;
        } else {
            char buf[INET_ADDRSTRLEN + 1] = {};
            inet_ntop(AF_INET, &std::get<0>(mAddr), buf, sizeof(buf));
            return buf;
        }
    }

    auto repr() const {
        return toString();
    }

    std::variant<in_addr, in6_addr> mAddr;
};

       struct SocketAddress {
    SocketAddress() = default;

    SocketAddress(IpAddress ip, int port) {
        std::visit([&](auto const &addr) { initFromHostPort(addr, port); },
                   ip.mAddr);
    }

    union {
        struct sockaddr_in mAddrIpv4;
        struct sockaddr_in6 mAddrIpv6;
        struct sockaddr mAddr;
    };

    socklen_t mAddrLen;

    sa_family_t family() const noexcept {
        return mAddr.sa_family;
    }

    IpAddress host() const {
        if (family() == AF_INET) {
            return IpAddress(mAddrIpv4.sin_addr);
        } else if (family() == AF_INET6) {
            return IpAddress(mAddrIpv6.sin6_addr);
        } else [[unlikely]] {
            throw std::runtime_error("address family not ipv4 or ipv6");
        }
    }

    int port() const {
        if (family() == AF_INET) {
            return ntohs(mAddrIpv4.sin_port);
        } else if (family() == AF_INET6) {
            return ntohs(mAddrIpv6.sin6_port);
        } else [[unlikely]] {
            throw std::runtime_error("address family not ipv4 or ipv6");
        }
    }

    auto repr() const {
        return host().toString() + ":" + to_string(port());
    }

private:
    void initFromHostPort(struct in_addr const &host, int port) {
        struct sockaddr_in saddr = {};
        saddr.sin_family = AF_INET;
        std::memcpy(&saddr.sin_addr, &host, sizeof(saddr.sin_addr));
        saddr.sin_port = htons(port);
        std::memcpy(&mAddrIpv4, &saddr, sizeof(saddr));
        mAddrLen = sizeof(saddr);
    }

    void initFromHostPort(struct in6_addr const &host, int port) {
        struct sockaddr_in6 saddr = {};
        saddr.sin6_family = AF_INET6;
        std::memcpy(&saddr.sin6_addr, &host, sizeof(saddr.sin6_addr));
        saddr.sin6_port = htons(port);
        std::memcpy(&mAddrIpv6, &saddr, sizeof(saddr));
        mAddrLen = sizeof(saddr);
    }
};

       struct [[nodiscard]] SocketHandle : FileHandle {
    using FileHandle::FileHandle;
};

       struct [[nodiscard]] SocketServer : SocketHandle {
    using SocketHandle::SocketHandle;

    SocketAddress mAddr;

    SocketAddress const &address() const noexcept {
        return mAddr;
    }
};

       inline SocketAddress get_socket_address(SocketHandle &sock) {
    SocketAddress sa;
    sa.mAddrLen = sizeof(sa.mAddrIpv6);
    checkError(getsockname(sock.fileNo(), (sockaddr *)&sa.mAddr, &sa.mAddrLen));
    return sa;
}

template <class T>
inline T socketGetOption(SocketHandle &sock, int level, int optId) {
    T val;
    socklen_t len = sizeof(val);
    checkError(getsockopt(sock.fileNo(), level, optId, &val, &len));
    return val;
}

template <class T>
inline void socketSetOption(SocketHandle &sock, int level, int opt,
                            T const &optVal) {
    checkError(setsockopt(sock.fileNo(), level, opt, &optVal, sizeof(optVal)));
}

inline Task<SocketHandle> createSocket(int family, int type) {
    int fd = co_await uring_socket(loop, family, type, 0, 0);
    SocketHandle sock(fd);
    co_return sock;
}

       inline Task<SocketHandle> socket_connect(SocketAddress const &addr) {
    SocketHandle sock = co_await createSocket(addr.family(), SOCK_STREAM);
    co_await uring_connect(loop, sock.fileNo(),
                           (const struct sockaddr *)&addr.mAddr, addr.mAddrLen);
    co_return sock;
}

       inline Task<SocketServer> server_bind(SocketAddress const &addr,
                                             int backlog = SOMAXCONN) {
    SocketHandle sock = co_await createSocket(addr.family(), SOCK_STREAM);
    socketSetOption(sock, SOL_SOCKET, SO_REUSEADDR, 1);
    SocketServer serv(sock.releaseFile());
    checkError(bind(serv.fileNo(), (struct sockaddr const *)&addr.mAddr,
                    addr.mAddrLen));
    checkError(listen(serv.fileNo(), backlog));
    serv.mAddr = addr;
    co_return serv;
}

       inline Task<SocketHandle> server_accept(SocketServer &serv) {
    int fd = co_await uring_accept(loop, serv.fileNo(),
                                   (struct sockaddr *)&serv.mAddr.mAddr,
                                   &serv.mAddr.mAddrLen, 0);
    SocketHandle sock(fd);
    co_return sock;
}

} // namespace co_async
#endif

// #line 1 "./co_async/http/http_server.cpp"




namespace co_async {

       struct HTTPServer {
    using HTTPHandler = Task<HTTPResponse> (*)(HTTPRequest const &);

    void addRoute(std::string_view path, HTTPHandler handler) {
        mRoutes.insert_or_assign(std::string(path), handler);
    }

    void defaultRoute(HTTPHandler handler) {
        mDefaultRoute = handler;
    }

    Task<HTTPResponse> handleRequest(HTTPRequest const &req) {
        if (auto handler = mRoutes.at(req.uri.path)) {
            co_return co_await (*handler)(req);
        }
        co_return co_await mDefaultRoute(req);
    }

    Task<> processConnection(FileStream stream) {
        HTTPRequest req;
        co_await req.read_from(stream);
        HTTPResponse res = co_await handleRequest(req);
        co_await res.write_into(stream);
        co_await fs_close(stream.release());
    }

private:
    SimpleMap<std::string, HTTPHandler> mRoutes;
    HTTPHandler mDefaultRoute = +[](HTTPRequest const &) {
        return makeDefaultErrorResponse(404);
    };

    static Task<HTTPResponse> makeDefaultErrorResponse(int status) {
        auto error =
            to_string(status) + " " + std::string(getHTTPStatusName(status));
        co_return {
            .status = status,
            .headers =
                {
                    {"content-type", "text/html;charset=utf-8"},
                },
            .body = "<html><head><title>" + error +
                    "</title></head><body><center><h1>" + error +
                    "</h1></center><hr><center>co_async</center></body></html>",
        };
    }
};

} // namespace co_async

// #line 1 "./co_async/awaiter/details/return_previous.cpp"




namespace co_async {

struct ReturnPreviousPromise {
    auto initial_suspend() noexcept {
        return std::suspend_always();
    }

    auto final_suspend() noexcept {
        return PreviousAwaiter(mPrevious);
    }

    void unhandled_exception() {
        throw;
    }

    void return_value(std::coroutine_handle<> previous) noexcept {
        mPrevious = previous;
    }

    auto get_return_object() {
        return std::coroutine_handle<ReturnPreviousPromise>::from_promise(
            *this);
    }

    std::coroutine_handle<> mPrevious;

    ReturnPreviousPromise &operator=(ReturnPreviousPromise &&) = delete;
};

struct [[nodiscard]] ReturnPreviousTask {
    using promise_type = ReturnPreviousPromise;

    ReturnPreviousTask(std::coroutine_handle<promise_type> coroutine) noexcept
        : mCoroutine(coroutine) {}

    ReturnPreviousTask(ReturnPreviousTask &&) = delete;

    ~ReturnPreviousTask() {
        mCoroutine.destroy();
    }

    std::coroutine_handle<promise_type> mCoroutine;
};

} // namespace co_async

// #line 1 "./co_async/awaiter/when_all.cpp"




namespace co_async {

struct WhenAllCtlBlock {
    std::size_t mCount;
    std::coroutine_handle<> mPrevious{};
    std::exception_ptr mException{};
};

struct WhenAllAwaiter {
    bool await_ready() const noexcept {
        return false;
    }

    std::coroutine_handle<>
    await_suspend(std::coroutine_handle<> coroutine) const {
        if (mTasks.empty())
            return coroutine;
        mControl.mPrevious = coroutine;
        for (auto const &t: mTasks.subspan(0, mTasks.size() - 1))
            t.mCoroutine.resume();
        return mTasks.back().mCoroutine;
    }

    void await_resume() const {
        if (mControl.mException) [[unlikely]] {
            std::rethrow_exception(mControl.mException);
        }
    }

    WhenAllCtlBlock &mControl;
    std::span<ReturnPreviousTask const> mTasks;
};

template <class T>
ReturnPreviousTask whenAllHelper(auto &&t, WhenAllCtlBlock &control,
                                 Uninitialized<T> &result) {
    try {
        result.putValue(co_await std::forward<decltype(t)>(t));
    } catch (...) {
        control.mException = std::current_exception();
        co_return control.mPrevious;
    }
    --control.mCount;
    if (control.mCount == 0) {
        co_return control.mPrevious;
    }
    co_return std::noop_coroutine();
}

template <class = void>
ReturnPreviousTask whenAllHelper(auto &&t, WhenAllCtlBlock &control,
                                 Uninitialized<void> &) {
    try {
        co_await std::forward<decltype(t)>(t);
    } catch (...) {
        control.mException = std::current_exception();
        co_return control.mPrevious;
    }
    --control.mCount;
    if (control.mCount == 0) {
        co_return control.mPrevious;
    }
    co_return std::noop_coroutine();
}

template <std::size_t... Is, class... Ts>
Task<std::tuple<typename AwaitableTraits<Ts>::NonVoidRetType...>>
whenAllImpl(std::index_sequence<Is...>, Ts &&...ts) {
    WhenAllCtlBlock control{sizeof...(Ts)};
    std::tuple<Uninitialized<typename AwaitableTraits<Ts>::RetType>...> result;
    ReturnPreviousTask taskArray[]{
        whenAllHelper(ts, control, std::get<Is>(result))...};
    co_await WhenAllAwaiter(control, taskArray);
    co_return std::tuple<typename AwaitableTraits<Ts>::NonVoidRetType...>(
        std::get<Is>(result).moveValue()...);
}

       template <Awaitable... Ts>
    requires(sizeof...(Ts) != 0)
auto when_all(Ts &&...ts) {
    return whenAllImpl(std::make_index_sequence<sizeof...(Ts)>{},
                       std::forward<Ts>(ts)...);
}

       template <Awaitable T, class Alloc = std::allocator<T>>
Task<std::conditional_t<
    std::same_as<void, typename AwaitableTraits<T>::RetType>,
    std::vector<typename AwaitableTraits<T>::RetType, Alloc>, void>>
when_all(std::vector<T, Alloc> const &tasks) {
    WhenAllCtlBlock control{tasks.size()};
    Alloc alloc = tasks.get_allocator();
    std::vector<Uninitialized<typename AwaitableTraits<T>::RetType>, Alloc>
        result(tasks.size(), alloc);
    {
        std::vector<ReturnPreviousTask, Alloc> taskArray(alloc);
        taskArray.reserve(tasks.size());
        for (std::size_t i = 0; i < tasks.size(); ++i) {
            taskArray.push_back(whenAllHelper(tasks[i], control, result[i]));
        }
        co_await WhenAllAwaiter(control, taskArray);
    }
    if constexpr (!std::same_as<void, typename AwaitableTraits<T>::RetType>) {
        std::vector<typename AwaitableTraits<T>::RetType, Alloc> res(alloc);
        res.reserve(tasks.size());
        for (auto &r: result) {
            res.push_back(r.moveValue());
        }
        co_return res;
    }
}

} // namespace co_async

// #line 1 "./co_async/awaiter/when_any.cpp"




namespace co_async {

struct WhenAnyCtlBlock {
    static constexpr std::size_t kNullIndex = std::size_t(-1);

    std::size_t mIndex{kNullIndex};
    std::coroutine_handle<> mPrevious{};
    std::exception_ptr mException{};
};

struct WhenAnyAwaiter {
    bool await_ready() const noexcept {
        return false;
    }

    std::coroutine_handle<>
    await_suspend(std::coroutine_handle<> coroutine) const {
        if (mTasks.empty())
            return coroutine;
        mControl.mPrevious = coroutine;
        for (auto const &t: mTasks.subspan(0, mTasks.size() - 1))
            t.mCoroutine.resume();
        return mTasks.back().mCoroutine;
    }

    void await_resume() const {
        if (mControl.mException) [[unlikely]] {
            std::rethrow_exception(mControl.mException);
        }
    }

    WhenAnyCtlBlock &mControl;
    std::span<ReturnPreviousTask const> mTasks;
};

template <class T>
ReturnPreviousTask whenAnyHelper(auto &&t, WhenAnyCtlBlock &control,
                                 Uninitialized<T> &result, std::size_t index) {
    try {
        result.putValue(
            (co_await std::forward<decltype(t)>(t), NonVoidHelper<>()));
    } catch (...) {
        control.mException = std::current_exception();
        co_return control.mPrevious;
    }
    control.mIndex = index;
    co_return control.mPrevious;
}

template <std::size_t... Is, class... Ts>
Task<std::variant<typename AwaitableTraits<Ts>::NonVoidRetType...>>
whenAnyImpl(std::index_sequence<Is...>, Ts &&...ts) {
    WhenAnyCtlBlock control{};
    std::tuple<Uninitialized<typename AwaitableTraits<Ts>::RetType>...> result;
    ReturnPreviousTask taskArray[]{
        whenAnyHelper(ts, control, std::get<Is>(result), Is)...};
    co_await WhenAnyAwaiter(control, taskArray);
    Uninitialized<std::variant<typename AwaitableTraits<Ts>::NonVoidRetType...>>
        varResult;
    ((control.mIndex == Is &&
      (varResult.putValue(std::in_place_index<Is>,
                          std::get<Is>(result).moveValue()),
       0)),
     ...);
    co_return varResult.moveValue();
}

       template <Awaitable... Ts>
    requires(sizeof...(Ts) != 0)
auto when_any(Ts &&...ts) {
    return whenAnyImpl(std::make_index_sequence<sizeof...(Ts)>{},
                       std::forward<Ts>(ts)...);
}

       template <Awaitable T, class Alloc = std::allocator<T>>
Task<typename AwaitableTraits<T>::RetType>
when_any(std::vector<T, Alloc> const &tasks) {
    WhenAnyCtlBlock control{tasks.size()};
    Alloc alloc = tasks.get_allocator();
    Uninitialized<typename AwaitableTraits<T>::RetType> result;
    {
        std::vector<ReturnPreviousTask, Alloc> taskArray(alloc);
        taskArray.reserve(tasks.size());
        for (auto &task: tasks) {
            taskArray.push_back(whenAllHelper(task, control, result));
        }
        co_await WhenAnyAwaiter(control, taskArray);
    }
    co_return result.moveValue();
}

} // namespace co_async

// #line 1 "./co_async/iostream/stdio_stream.cpp"


#ifdef __linux__
#include <unistd.h>
#include <termios.h>
#endif





namespace co_async {

inline void disableCanon(FileHandle &file) {
    if (isatty(file.fileNo())) {
        struct termios tc;
        tcgetattr(file.fileNo(), &tc);
        tc.c_lflag &= ~ICANON;
        tc.c_lflag &= ~ECHO;
        tcsetattr(file.fileNo(), TCSANOW, &tc);
    }
}

       struct StdioBuf {
    FileHandle &mFileIn;
    FileHandle &mFileOut;

    Task<std::size_t> read(std::span<char> buffer) {
        return fs_read(mFileIn, buffer);
    }

    Task<std::size_t> write(std::span<char const> buffer) {
        return fs_write(mFileOut, buffer);
    }
};

       using StdioStream = IOStream<StdioBuf>;

template <int fileNo>
inline FileHandle &stdHandle() {
    static FileHandle h(fileNo);
    return h;
}

       inline StdioStream &ios() {
    static thread_local StdioStream s(stdHandle<STDIN_FILENO>(),
                                      stdHandle<STDOUT_FILENO>());
    return s;
}

} // namespace co_async

// #line 1 "./co_async/iostream/string_stream.cpp"




namespace co_async {

       struct StringReadBuf {
    std::string_view mStringView;
    std::size_t mPosition;

    StringReadBuf() noexcept : mPosition(0) {}

    StringReadBuf(std::string_view strView)
        : mStringView(strView),
          mPosition(0) {}

    Task<std::size_t> read(std::span<char> buffer) {
        std::size_t size =
            std::min(buffer.size(), mStringView.size() - mPosition);
        std::copy_n(mStringView.begin() + mPosition, size, buffer.begin());
        mPosition += size;
        co_return size;
    }

    std::string_view str() const noexcept {
        return mStringView;
    }

    std::string_view unread_str() const noexcept {
        return mStringView.substr(mPosition);
    }
};

       struct StringWriteBuf {
    std::string mString;

    StringWriteBuf() noexcept {}

    StringWriteBuf(std::string &&str) noexcept : mString(std::move(str)) {}

    StringWriteBuf(std::string_view str) : mString(str) {}

    Task<std::size_t> write(std::span<char const> buffer) {
        mString.append(buffer.data(), buffer.size());
        co_return buffer.size();
    }

    std::string_view str() const noexcept {
        return mString;
    }

    std::string release() noexcept {
        return std::move(mString);
    }
};

       using StringIStream = IStream<StringReadBuf>;
       using StringOStream = OStream<StringWriteBuf>;

} // namespace co_async

// #line 1 "./co_async/co_async.cpp"



// #line 1 "./co_async/awaiter/generator.cpp"




namespace co_async {

template <class T>
struct GeneratorPromise {
    auto initial_suspend() noexcept {
        return std::suspend_always();
    }

    auto final_suspend() noexcept {
        return PreviousAwaiter(mPrevious);
    }

    void unhandled_exception() noexcept {
        mException = std::current_exception();
        mFinal = true;
    }

    auto yield_value(T &&ret) {
        mResult.putValue(std::move(ret));
        return PreviousAwaiter(mPrevious);
    }

    auto yield_value(T const &ret) {
        mResult.putValue(ret);
        return PreviousAwaiter(mPrevious);
    }

    void return_void() {
        mFinal = true;
    }

    bool final() {
        if (mFinal) {
            if (mException) [[unlikely]] {
                std::rethrow_exception(mException);
            }
        }
        return mFinal;
    }

    T result() {
        return mResult.moveValue();
    }

    auto get_return_object() {
        return std::coroutine_handle<GeneratorPromise>::from_promise(*this);
    }

    std::coroutine_handle<> mPrevious;
    bool mFinal = false;
    Uninitialized<T> mResult;
    std::exception_ptr mException{};

    GeneratorPromise &operator=(GeneratorPromise &&) = delete;
};

template <class T>
struct GeneratorPromise<T &> {
    auto initial_suspend() noexcept {
        return std::suspend_always();
    }

    auto final_suspend() noexcept {
        return PreviousAwaiter(mPrevious);
    }

    void unhandled_exception() noexcept {
        mException = std::current_exception();
        mResult = nullptr;
    }

    auto yield_value(T &ret) {
        mResult = std::addressof(ret);
        return PreviousAwaiter(mPrevious);
    }

    void return_void() {
        mResult = nullptr;
    }

    bool final() {
        if (!mResult) {
            if (mException) [[unlikely]] {
                std::rethrow_exception(mException);
            }
            return true;
        }
        return false;
    }

    T &result() {
        return *mResult;
    }

    auto get_return_object() {
        return std::coroutine_handle<GeneratorPromise>::from_promise(*this);
    }

    std::coroutine_handle<> mPrevious{};
    T *mResult;
    std::exception_ptr mException{};

    GeneratorPromise &operator=(GeneratorPromise &&) = delete;
};

template <class T, class P = GeneratorPromise<T>>
struct [[nodiscard]] Generator {
    using promise_type = P;

    Generator(std::coroutine_handle<promise_type> coroutine = nullptr) noexcept
        : mCoroutine(coroutine) {}

    Generator(Generator &&that) noexcept : mCoroutine(that.mCoroutine) {
        that.mCoroutine = nullptr;
    }

    Generator &operator=(Generator &&that) noexcept {
        std::swap(mCoroutine, that.mCoroutine);
    }

    ~Generator() {
        if (mCoroutine)
            mCoroutine.destroy();
    }

    struct Awaiter {
        bool await_ready() const noexcept {
            return false;
        }

        std::coroutine_handle<promise_type>
        await_suspend(std::coroutine_handle<> coroutine) const noexcept {
            mCoroutine.promise().mPrevious = coroutine;
            return mCoroutine;
        }

        std::optional<T> await_resume() const {
            if (mCoroutine.promise().final())
                return std::nullopt;
            return mCoroutine.promise().result();
        }

        std::coroutine_handle<promise_type> mCoroutine;
    };

    auto operator co_await() const noexcept {
        return Awaiter(mCoroutine);
    }

    operator std::coroutine_handle<promise_type>() const noexcept {
        return mCoroutine;
    }

private:
    std::coroutine_handle<promise_type> mCoroutine;
};

#if 0
template <class T, class A, class LoopRef>
struct GeneratorIterator {
    using iterator_category = std::input_iterator_tag;
    using value_type = T;
    using difference_type = std::ptrdiff_t;
    using pointer = T *;
    using reference = T &;

    explicit GeneratorIterator(A awaiter, LoopRef loop) noexcept
        : mAwaiter(awaiter),
          mLoop(loop) {
        ++*this;
    }

    bool operator!=(std::default_sentinel_t) const noexcept {
        return mResult.has_value();
    }

    bool operator==(std::default_sentinel_t) const noexcept {
        return !(*this != std::default_sentinel);
    }

    friend bool operator==(std::default_sentinel_t,
                           GeneratorIterator const &it) noexcept {
        return it == std::default_sentinel;
    }

    friend bool operator!=(std::default_sentinel_t,
                           GeneratorIterator const &it) noexcept {
        return it == std::default_sentinel;
    }

    GeneratorIterator &operator++() {
        mAwaiter.mCoroutine.resume();
        mLoop.run();
        mResult = mAwaiter.await_resume();
        return *this;
    }

    GeneratorIterator operator++(int) {
        auto tmp = *this;
        ++*this;
        return tmp;
    }

    T &operator*() noexcept {
        return *mResult;
    }

    T *operator->() noexcept {
        return mResult.operator->();
    }

private:
    A mAwaiter;
    LoopRef mLoop;
    std::optional<T> mResult;
};

template <class Loop, class T, class P>
auto run_generator_on(Loop &loop, Generator<T, P> const &g) {
    using Awaiter = typename Generator<T, P>::Awaiter;

    struct GeneratorRange {
        explicit GeneratorRange(Awaiter awaiter, Loop &loop)
            : mAwaiter(awaiter),
              mLoop(loop) {
            mAwaiter.await_suspend(std::noop_coroutine());
        }

        auto begin() const noexcept {
            return GeneratorIterator<T, Awaiter, Loop &>(mAwaiter, mLoop);
        }

        std::default_sentinel_t end() const noexcept {
            return {};
        }

    private:
        Awaiter mAwaiter;
        Loop &mLoop;
    };

    return GeneratorRange(g.operator co_await(), loop);
};
#endif

} // namespace co_async

// #line 1 "./co_async/awaiter/and_then.cpp"




namespace co_async {

       template <Awaitable A,
                 std::invocable<typename AwaitableTraits<A>::RetType> F>
    requires(!std::same_as<void, typename AwaitableTraits<A>::RetType>)
Task<typename AwaitableTraits<
    std::invoke_result_t<F, typename AwaitableTraits<A>::RetType>>::Type>
and_then(A &&a, F &&f) {
    co_return co_await ensureAwaitable(
        std::forward<F>(f)(co_await std::forward<A>(a)));
}

       template <Awaitable A, std::invocable<> F>
    requires(std::same_as<void, typename AwaitableTraits<A>::RetType>)
Task<typename AwaitableTraits<std::invoke_result_t<F>>::Type> and_then(A &&a,
                                                                       F &&f) {
    co_await std::forward<A>(a);
    co_return co_await ensureAwaitable(std::forward<F>(f)());
}

       template <Awaitable A, Awaitable F>
    requires(!std::invocable<F> &&
             !std::invocable<F, typename AwaitableTraits<A>::RetType>)
Task<typename AwaitableTraits<F>::RetType> and_then(A &&a, F &&f) {
    co_await std::forward<A>(a);
    co_return co_await std::forward<F>(f);
}

} // namespace co_async

// #line 1 "./co_async/awaiter/details/make_awaitable.cpp"




namespace co_async {

template <Awaitable A>
A &&ensureAwaitable(A &&a) {
    return std::forward<A>(a);
}

template <class A>
    requires(!Awaitable<A>)
Task<A> ensureAwaitable(A &&a) {
    co_return std::forward<A>(a);
}

template <Awaitable A>
Task<typename AwaitableTraits<A>::RetType> ensureTask(A a) {
    co_return co_await std::move(a);
}

template <class T>
Task<T> ensureTask(Task<T> &&t) {
    return std::move(t);
}

template <class A>
    requires(!Awaitable<A> && std::invocable<A> &&
             Awaitable<std::invoke_result_t<A>>)
Task<typename AwaitableTraits<std::invoke_result_t<A>>::RetType>
ensureTask(A a) {
    return ensureTask(std::invoke(std::move(a)));
}

} // namespace co_async

// #line 1 "./co_async/awaiter/details/current_coroutine.cpp"




namespace co_async {

struct CurrentCoroutineAwaiter {
    bool await_ready() const noexcept {
        return false;
    }

    std::coroutine_handle<>
    await_suspend(std::coroutine_handle<> coroutine) noexcept {
        mCurrent = coroutine;
        return coroutine;
    }

    auto await_resume() const noexcept {
        return mCurrent;
    }

    std::coroutine_handle<> mCurrent;
};

} // namespace co_async

// #line 1 "./co_async/utils/rbtree.cpp"




namespace co_async {

template <class Value, class Compare = std::less<Value>>
struct RbTree {
    enum RbColor {
        RED,
        BLACK
    };

    struct RbNode {
        RbNode() noexcept
            : left(nullptr),
              right(nullptr),
              parent(nullptr),
              tree(nullptr),
              color(RED) {}

        RbNode(RbNode &&) = delete;

        ~RbNode() noexcept {
            if (tree) {
                tree->doErase(this);
            }
        }

        friend struct RbTree;

    private:
        RbNode *left;
        RbNode *right;
        RbNode *parent;
        RbTree *tree;
        RbColor color;
    };

private:
    RbNode *root;
    Compare comp;

    bool compare(RbNode *left, RbNode *right) const noexcept {
        return comp(static_cast<Value &>(*left), static_cast<Value &>(*right));
    }

    void rotateLeft(RbNode *node) noexcept {
        RbNode *rightChild = node->right;
        node->right = rightChild->left;
        if (rightChild->left != nullptr) {
            rightChild->left->parent = node;
        }
        rightChild->parent = node->parent;
        if (node->parent == nullptr) {
            root = rightChild;
        } else if (node == node->parent->left) {
            node->parent->left = rightChild;
        } else {
            node->parent->right = rightChild;
        }
        rightChild->left = node;
        node->parent = rightChild;
    }

    void rotateRight(RbNode *node) noexcept {
        RbNode *leftChild = node->left;
        node->left = leftChild->right;
        if (leftChild->right != nullptr) {
            leftChild->right->parent = node;
        }
        leftChild->parent = node->parent;
        if (node->parent == nullptr) {
            root = leftChild;
        } else if (node == node->parent->right) {
            node->parent->right = leftChild;
        } else {
            node->parent->left = leftChild;
        }
        leftChild->right = node;
        node->parent = leftChild;
    }

    void fixViolation(RbNode *node) noexcept {
        RbNode *parent = nullptr;
        RbNode *grandParent = nullptr;

        while (node != root && node->color != BLACK &&
               node->parent->color == RED) {
            parent = node->parent;
            grandParent = parent->parent;

            if (parent == grandParent->left) {
                RbNode *uncle = grandParent->right;

                if (uncle != nullptr && uncle->color == RED) {
                    grandParent->color = RED;
                    parent->color = BLACK;
                    uncle->color = BLACK;
                    node = grandParent;
                } else {
                    if (node == parent->right) {
                        rotateLeft(parent);
                        node = parent;
                        parent = node->parent;
                    }
                    rotateRight(grandParent);
                    std::swap(parent->color, grandParent->color);
                    node = parent;
                }
            } else {
                RbNode *uncle = grandParent->left;

                if (uncle != nullptr && uncle->color == RED) {
                    grandParent->color = RED;
                    parent->color = BLACK;
                    uncle->color = BLACK;
                    node = grandParent;
                } else {
                    if (node == parent->left) {
                        rotateRight(parent);
                        node = parent;
                        parent = node->parent;
                    }
                    rotateLeft(grandParent);
                    std::swap(parent->color, grandParent->color);
                    node = parent;
                }
            }
        }

        root->color = BLACK;
    }

    void doInsert(RbNode *node) noexcept {
        node->left = nullptr;
        node->right = nullptr;
        node->tree = this;
        node->color = RED;

        RbNode *parent = nullptr;
        RbNode *current = root;

        while (current != nullptr) {
            parent = current;
            if (compare(node, current)) {
                current = current->left;
            } else {
                current = current->right;
            }
        }

        node->parent = parent;
        if (parent == nullptr) {
            root = node;
        } else if (compare(node, parent)) {
            parent->left = node;
        } else {
            parent->right = node;
        }

        fixViolation(node);
    }

    /* template <class Key> */
    /* RbNode* doFind(Key &&key) const { */
    /*     RbNode* current = root; */
    /*     // Find the node to delete */
    /*     while (current != nullptr) { */
    /*         if (key_compare(key, current)) { */
    /*             current = current->left; */
    /*         } else { */
    /*             current = current->right; */
    /*         } */
    /*     } */
    /*     return nullptr; */
    /* } */

    /* void doErase(RbNode* node) noexcept { */
    /*     RbNode* parent = nullptr; */
    /*  */
    /*     // Case 1: Node to delete has no children */
    /*     if (node->left == nullptr && node->right == nullptr) { */
    /*         if (node == root) { */
    /*             root = nullptr; */
    /*         } else { */
    /*             if (node == parent->left) { */
    /*                 parent->left = nullptr; */
    /*             } else { */
    /*                 parent->right = nullptr; */
    /*             } */
    /*         } */
    /*         delete node; */
    /*     } */
    /*     // Case 2: Node to delete has one child */
    /*     else if (node->left == nullptr || node->right == nullptr) { */
    /*         RbNode* child = (node->left != nullptr) ? node->left : node->right; */
    /*  */
    /*         if (node == root) { */
    /*             root = child; */
    /*         } else { */
    /*             if (node == parent->left) { */
    /*                 parent->left = child; */
    /*             } else { */
    /*                 parent->right = child; */
    /*             } */
    /*         } */
    /*         child->parent = parent; */
    /*         delete node; */
    /*     } */
    /*     // Case 3: Node to delete has two children */
    /*     else { */
    /*         RbNode* successor = node->right; */
    /*         while (successor->left != nullptr) { */
    /*             successor = successor->left; */
    /*         } */
    /*         doErase(successor); */
    /*     } */
    /* } */

    void doErase(RbNode *current) noexcept {
        current->tree = nullptr;

        RbNode *node = nullptr;
        RbNode *child = nullptr;
        RbColor color = RED;

        if (current->left != nullptr && current->right != nullptr) {
            RbNode *replace = current;
            replace = replace->right;
            while (replace->left != nullptr) {
                replace = replace->left;
            }

            if (current != replace->parent) {
                current->parent->left = replace->right;
                replace->right = current->right;
                current->right->parent = replace;
            } else {
                replace->parent = current;
            }

            if (current == root) {
                root = replace;
            } else if (current->parent->left == current) {
                current->parent->left = replace;
            } else {
                current->parent->right = replace;
            }

            replace->left = current->left;
            current->left->parent = replace;

            node = replace;
            color = node->color;
            child = node->right;
        } else {
            node = current;
            color = node->color;
            child = (node->left != nullptr) ? node->left : node->right;
        }

        if (child != nullptr) {
            child->parent = node->parent;
        }

        if (node == root) {
            root = child;
        } else if (node->parent->left == node) {
            node->parent->left = child;
        } else {
            node->parent->right = child;
        }

        if (color == BLACK && root) {
            fixViolation(child ? child : node->parent);
        }
    }

    RbNode *getFront() const noexcept {
        RbNode *current = root;
        while (current->left != nullptr) {
            current = current->left;
        }
        return current;
    }

    RbNode *getBack() const noexcept {
        RbNode *current = root;
        while (current->right != nullptr) {
            current = current->right;
        }
        return current;
    }

    template <class Visitor>
    void doTraversalInorder(RbNode *node, Visitor &&visitor) {
        if (node == nullptr) {
            return;
        }

        traversalInorder(node->left, visitor);
        visitor(node);
        doTraversalInorder(node->right, visitor);
    }

public:
    RbTree() noexcept : root(nullptr) {}

    explicit RbTree(Compare comp) noexcept(noexcept(Compare(comp)))
        : root(nullptr),
          comp(comp) {}

    RbTree(RbTree &&) = delete;

    ~RbTree() noexcept {}

    void insert(Value &value) noexcept {
        doInsert(&static_cast<RbNode &>(value));
    }

    void erase(Value &value) noexcept {
        doErase(&static_cast<RbNode &>(value));
    }

    bool empty() const noexcept {
        return root == nullptr;
    }

    Value &front() const noexcept {
        return static_cast<Value &>(*getFront());
    }

    Value &back() const noexcept {
        return static_cast<Value &>(*getBack());
    }

    template <class Visitor>
    void traversalInorder(Visitor &&visitor) {
        doTraversalInorder(root, std::forward<Visitor>(visitor));
    }
};

} // namespace co_async

